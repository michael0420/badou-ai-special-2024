# （1）双线性插值
**插值我们要记住的一点就是：由目标图的坐标反推再原图上的位置。即由已知点求未知点。就是：已知目标图的像素坐标去找原图上的像素坐标。算得的插值是一个估计值。**

单线性插值》》》双线性插值（相似三角形原理）
算法的本质就是：求一个虚拟点的像素值。

![image](https://github.com/pengsuhua/badou-ai-special-2024/assets/116246948/172da03e-e302-412f-83db-f7e47e14f5a2)


**还有就是有一个中心对称的问题：**
![image](https://github.com/pengsuhua/badou-ai-special-2024/assets/116246948/9ad4353e-fbcb-41ae-b70c-1b1553767463)
![image](https://github.com/pengsuhua/badou-ai-special-2024/assets/116246948/fb90a605-f98d-44d3-8e8e-53f19c38343a)
![image](https://github.com/pengsuhua/badou-ai-special-2024/assets/116246948/1aa3d89a-72b8-44e1-a434-8a09edf99fc9)
![image](https://github.com/pengsuhua/badou-ai-special-2024/assets/116246948/5559cb72-8797-4bf4-b48f-7003d4d15ead)


# （2）直方图均衡化：
有对灰度图的直方图均衡化和彩色图像的直方图均衡化。
直方图有：颜色直方图，灰度直方图等。
**图像的灰度直方图就描述了图像中灰度分布情况，能够很直观的展示出图像中各个灰度级所占的多少。
图像的灰度直方图是灰度级的函数，描述的是图像中具有该灰度级的像素的个数：其中，横坐标是灰度级，纵坐标是该灰度级出现的频率。**

• 直方图反映了图像中的**灰度分布规律**。它描述每个灰度级具有的**像素个数**，但不包含这些像素在图像中的位置信息。图像直方图不关心像素所处的空间位置，因此不受图像旋转和平移变化的影响，可以作为图像的特征。
• 任何一幅特定的图像都有唯一的直方图与之对应，但不同的图像可以有相同的直方图。
• 如果一幅图像有两个不相连的区域组成，并且每个区域的直方图已知，则整幅图像的直方图是该两个区域的直方图之和。

**直方图均衡化是将原图像的直方图通过变换函数变为均匀的直方图，然后按均匀直方图修改原图像，从而获得一幅灰度分布均匀的新图像。直方图均衡化就是用一定的算法使直方图大致平和的方法。
直方图均衡化的作用是图像增强。**
![image](https://github.com/pengsuhua/badou-ai-special-2024/assets/116246948/bbbf41ed-a66f-47a3-8c7d-f831348145fb)


# （3）卷积：也叫做滤波---过滤器/卷积核/Kernel
对于滤波器，也有一定的规则要求：
1）**滤波器的大小应该是奇数**，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。
2）滤波器矩阵所有的元素之和应该要等于1，这是为了保证滤波前后图像的亮度保持不变。但这不是硬性要求。
3）如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。
4）对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。

**在具体应用中，往往有多个卷积核，可以认为，每个卷积核代表了一种图像模式。
如果某个图像块与此卷积核卷积出的值大，则认为此图像块十分接近于此卷积核。**
![image](https://github.com/pengsuhua/badou-ai-special-2024/assets/116246948/45ecd9a8-f0b7-4e89-90bb-66fabd44a417)
![image](https://github.com/pengsuhua/badou-ai-special-2024/assets/116246948/96af9fa0-5178-46bc-923b-accd5d585c68)
![image](https://github.com/pengsuhua/badou-ai-special-2024/assets/116246948/d316d0a6-d922-4532-b4d3-63bcba39d006)
（有单通道的卷积，多通道的卷积）

**记住：
卷积核通道数 = 输入通道数
输出通道数 = 卷积核的个数 
（个数和通道数要理解）**


# （4）Sobel算子边缘检测：

就是在写代码实现的时候要注意：
**1）Sobel算子通常用于边缘检测，尤其是在图像的梯度计算中。**
虽然它通常用于灰度图像，但它也可以应用于彩色图像的每个通道。具体来说，可以对RGB图像的每个通道分别应用Sobel算子，然后将结果合并以得到最终的边缘检测结果。但需要注意的是，直接在彩色图像上应用Sobel算子可能会导致边缘检测结果受到颜色信息的影响，
因此在某些情况下，可能会首先将彩色图像转换为灰度图像，然后应用Sobel算子进行边缘检测，以获得更好的结果。
**2）Sobel函数求完导数之后会有负值，还会有大于255的值。**
而原图像是uint8,即8位无符号数，范围在【0，255】，所以Sobel函数所建立的图像位数不够，会有截断。因此要使用16位有符号数的数据类型，即:cv2.CV_16S。
**3）在经过处理后，别忘了用convertScaleAbs()函数将其转回原来的uint8形式。**
否则将无法显示图像，而只是一副灰色的窗口。dst = cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])  其中可选参数alpha是伸缩系数，beta是加到结果上的一个值。结果返回uint8类型的图片。
**4）由于Sobel函数是在两个方向计算的，最后还需要用：cv2.addWeighted()函数将x,y方向上的计算的值组合起来。**
其函数原型是：dest = cv2.addweighted(src1,slpha,src2,beta,gamma[,[dst[,dtype]])
其中alpha:是第一个元素的权重，bata是第二个元素的权重。gamma是加到最后结果上的一个值。
